=head0 Grammars

Grammars organize regexes, just like  classes organize methods. The following
example demonstrates how to parse JSON, a data exchange format already
introduced in the chapter on multi dispatch (TODO: make this a proper
reference).

    # file lib/JSON/Tiny/Grammar.pg

    grammar JSON::Tiny::Grammar {
        rule TOP {
            ^ [
                | <object> {*}      #= object
                | <array>  {*}      #= array
            ] $
        }
        rule object     { '{' ~ '}' <pairlist>      {*}   }
        rule pairlist   {
            <pair> ** ','
            {*}
        }

        rule pair {
            <string> ':' <value>        {*}
        }

        rule array {
            '[' ~ ']'
                [   
                    [ <value> ** ',' ]?
                    \s*
                ]
            {*}
        }

        # TODO: turn into a proto regex once they are implemented
        rule value {
            | <string>  {*}     #= string
            | <number>  {*}     #= number
            | <object>  {*}     #= object
            | <array>   {*}     #= array
            | 'true'    {*}     #= true
            | 'false'   {*}     #= false
            | 'null'    {*}     #= null
        }

        token string {
            \" ~ \" ([
                | <str>
                | \\ <str_escape>
            ]*) {*}
        }

        token str {
            <-["\\\t\n]>+
        }

        token str_escape {
            [
                <["\\/bfnrt]>
            | u <xdigit>**4
            ] {*}
        }

        token number {
            \- ?
            [ 0 | <[1..9]> <[0..9]>* ]
            [ \. <[0..9]>+ ]?
            [ <[eE]> [\+|\-]? <[0..9]>+ ]?
            {*}
        }
    }

    # test it:
    my $tester = '{
        "country":  "Austria",
        "cities": [ "Wien", "Salzburg", "Innsbruck" ],
        "population": 8353243
    }';

    if JSON::Tiny::Grammar.parse($tester) {
        say "It's valid JSON";
    } else {
        # TODO: error reporting
        say "Not quite...";
    }

A grammar contains various named regexes, one of which is
called C<TOP>, and is called by C<JSON::Tiny.parse($string)>.

Rule C<TOP> anchors the match to the start and end of the string, so that the
whole string has to be in valid JSON format for the match to succeed. It then
either matches an C<< <array> >> or an C<< <object> >>, both of which are
defined later on. The C<{*}> provides hook which will later make it easier to
access specific parts of the string. The C<#= object> and C<#= array> markers
don't influence the match in any way,  the just provide labels that makes it
easier to determine which of the two alternatives matched.

The following calls are straightforward, and reflect the structure in which
JSON components can appear. This includes some recursive calls: For example
C<array> calls C<value>, and C<value> again calls C<array>. That's fine as
long as at least one regex per recursion cycle consumes at least one
character. If not, the (mutual) recursion can go on infinitely, never
progressing in the string, or to other parts of the grammar.

The only new regex syntax used in the C<JSON::Tiny> grammar is the
I<goal matching> syntax C<'{' ~ '}' [ ... ]>, which is something similar
like C<'{' ... '}'>, but gives a better error message if it fails.

=head1 Grammar Inheritance

It was mentioned earlier that grammars manage regexes just like classes manage
methods. This analogy goes deeper than just having a namespace to put routines
or regexes into - you can inherit grammars just like classes, mix roles into
them, and benefit from the usual polymorphism.

Suppose you wanted to enhance the JSON grammar to allow single-line javascript
comments. The simplest enhancement is to allow it in any place where
whitespace is also allowed.

Whitespace is currently done by having some rules which implicitly enable the
C<:sigspace> modifier. Which in turn internally replaces all whitespaces in
the regex to calls to the C<ws> token. So all you've got to do is to override
that:

    grammar JSON::Tiny::Grammar::WithComments
        is JSON::Tiny::Grammar {

        token ws {
            \s* [ '//' \N* \n ]?
        }
    }

    my $tester = '{
        "country":  "Austria",
        "cities": [ "Wien", "Salzburg", "Innsbruck" ],
        "population": 8353243 // data from 2009-01
    }';
    if JSON::Tiny::Grammar::WithComments.parse($tester) {
        say "It's valid (modified) JSON";
    }

The first two lines introduce a grammar that inherits from
C<JSON::Tiny::Grammar>. The inheritance is specified with the C<is> trait.
This means that the grammar rules are now called from the child grammar if it
exists there, and from the parent grammar otherwise - just like normal method
calls.

In (our relaxed) JSON whitespaces are never mandatory, so the C<ws> is allowed
to match nothing at all. After optional spaces two slashes C<'//'>  introduce a
comment, which is followed by an arbitrary number of characters that are not
newlines, and then a newline -- in prose: it extends to the rest of the line.

=head1 Extracting data

The C<parse> method of a grammar returns a C<Match> object, and through the
captures you can access all the relevant information. However to do that you
have to write a function that traverses the match tree recursively, and
search for bits and pieces you are interested in. Since this is a cumbersome
task, an alternative solution exist: I<actions method>.

    # TODO: example for JSON actions methods
    # since this is going to change quite a bit
    # with upcoming Rakudo changes I don't bother to
    # put it in and explain it in detail right now

    my $actions = JSON::Tiny::Actions.new();
    JSON::Tiny::Grammar.parse($str, :$actions);

    # RAKUDO doesn't call action methods at the
    # end of each each rule yet

We pass an actions object to the grammar's C<parse> method. Whenever the
grammar engine finishes parsing one rule, or encounters a C<{*}> token in the
grammar, it calls an method of the match object, with the same name as
the current rule. If no such method is found, it is silently ignored.

It passes the current match object as the first positional argument, and
optionally as a second argument the name of the current branch, which can be
set with C<#= name> at the end of a line.

Each match object has a slot C<ast> for a payload object, called
I<abstract syntax tree>. It can hold a custom data structure that you create
from the match object. Calling C<make $thing> in an action method sets the
C<ast> attribute of the current match object to C<$thing>.

In the case of our JSON parser the payload can be directly the data structure
which corresponds that the JSON string represents.

=for vim: spell spelllang=en tw=78
